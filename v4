#include <U8g2lib.h>
#include <WiFi.h>
#include <WebServer.h>

// Pin Definitions
#define BUTTON_UP 18
#define BUTTON_DOWN 19
#define BUTTON_SELECT 5

// OLED Display
U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);

// WiFi AP Configuration
const char* ssid = "Tomato_Sorter";
const char* password = "tomato123";
WebServer server(80);

// Menu States
enum MenuState {
  MAIN_MENU,
  STATISTICS_MENU,
  CHECK_STATISTICS,
  RESET_STATISTICS,
  SORTING_SCREEN
};

MenuState currentState = MAIN_MENU;
int menuIndex = 0;

// Statistics counters
int countRed = 0;
int countOrange = 0;
int countGreen = 0;

// Sorting state
bool isSorting = false;

// Button debouncing
unsigned long lastDebounceTime = 0;
const long debounceInterval = 200;

// Reset screen timing
unsigned long resetDisplayTime = 0;
bool showingResetMessage = false;

// IP Address
String ipAddress = "";

void setup() {
  Serial.begin(115200);
  
  // Initialize buttons
  pinMode(BUTTON_UP, INPUT_PULLUP);
  pinMode(BUTTON_DOWN, INPUT_PULLUP);
  pinMode(BUTTON_SELECT, INPUT_PULLUP);
  
  // Initialize OLED
  u8g2.begin();
  
  // Setup WiFi Access Point
  setupWiFiAP();
  
  // Setup web server routes
  setupWebServer();
  
  // Show main menu
  displayMainMenu();
  
  Serial.println("Menu System Ready");
}

void loop() {
  unsigned long currentMillis = millis();
  
  // Handle web server
  server.handleClient();
  
  // Handle reset message timeout
  if (showingResetMessage && (currentMillis - resetDisplayTime >= 2000)) {
    showingResetMessage = false;
    // Return to appropriate state based on where reset was triggered
    if (isSorting) {
      currentState = SORTING_SCREEN;
      displaySortingScreen();
    } else {
      currentState = STATISTICS_MENU;
      menuIndex = 0;
      displayStatisticsMenu();
    }
  }
  
  // Handle button presses based on current state
  if (!showingResetMessage) {
    switch (currentState) {
      case MAIN_MENU:
        handleMainMenu(currentMillis);
        break;
        
      case STATISTICS_MENU:
        handleStatisticsMenu(currentMillis);
        break;
        
      case CHECK_STATISTICS:
        handleCheckStatistics(currentMillis);
        break;
        
      case SORTING_SCREEN:
        handleSortingScreen(currentMillis);
        break;
    }
  }
}

// ==================== WiFi SETUP ====================
void setupWiFiAP() {
  WiFi.softAP(ssid, password);
  ipAddress = WiFi.softAPIP().toString();
  
  Serial.println("Access Point Started");
  Serial.print("SSID: ");
  Serial.println(ssid);
  Serial.print("IP Address: ");
  Serial.println(ipAddress);
}

// ==================== WEB SERVER SETUP ====================
void setupWebServer() {
  server.on("/", handleRoot);
  server.on("/status", handleStatus);
  server.on("/start", handleStartSorting);
  server.on("/stop", handleStopSorting);
  server.on("/unstuck", handleUnstuck);
  server.on("/reset", handleResetStats);
  
  server.begin();
  Serial.println("Web Server Started");
}

void handleRoot() {
  String html = getHTML();
  server.send(200, "text/html", html);
}

void handleStatus() {
  String json = "{";
  json += "\"isSorting\":" + String(isSorting ? "true" : "false") + ",";
  json += "\"countRed\":" + String(countRed) + ",";
  json += "\"countOrange\":" + String(countOrange) + ",";
  json += "\"countGreen\":" + String(countGreen);
  json += "}";
  server.send(200, "application/json", json);
}

void handleStartSorting() {
  isSorting = true;
  currentState = SORTING_SCREEN;
  displaySortingScreen();
  server.send(200, "text/plain", "OK");
  Serial.println("Sorting started via web");
}

void handleStopSorting() {
  isSorting = false;
  currentState = MAIN_MENU;
  menuIndex = 0;
  displayMainMenu();
  server.send(200, "text/plain", "OK");
  Serial.println("Sorting stopped via web");
}

void handleUnstuck() {
  if (isSorting) {
    // Add your unstuck logic here
    Serial.println("Unstuck command received");
    server.send(200, "text/plain", "OK");
  } else {
    server.send(400, "text/plain", "Cannot unstuck when not sorting");
  }
}

void handleResetStats() {
  if (!isSorting) {
    countRed = 0;
    countOrange = 0;
    countGreen = 0;
    
    // Show reset message on OLED
    displayResetMessage();
    
    Serial.println("Statistics reset via web");
    server.send(200, "text/plain", "OK");
  } else {
    server.send(400, "text/plain", "Cannot reset while sorting");
  }
}

// ==================== HTML GENERATION ====================
String getHTML() {
  String html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tomato Sorter</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Courier New', monospace;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2e 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      color: #fff;
    }
    
    .container {
      background: rgba(20, 20, 40, 0.8);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 30px;
      max-width: 500px;
      width: 100%;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5),
                  inset 0 0 30px rgba(0, 255, 255, 0.1);
    }
    
    h1 {
      text-align: center;
      color: #00ffff;
      text-shadow: 0 0 20px #00ffff, 0 0 30px #00ffff;
      font-size: 2em;
      margin-bottom: 10px;
      letter-spacing: 3px;
    }
    
    .status {
      text-align: center;
      color: #ff00ff;
      font-size: 1.1em;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #ff00ff;
      min-height: 25px;
    }
    
    .buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-bottom: 30px;
    }
    
    button {
      background: linear-gradient(135deg, #00ffff 0%, #0080ff 100%);
      border: 2px solid #00ffff;
      color: #000;
      padding: 15px 25px;
      font-size: 1.1em;
      font-weight: bold;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
      font-family: 'Courier New', monospace;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    button:hover:not(:disabled) {
      background: linear-gradient(135deg, #00ffff 0%, #00ccff 100%);
      box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
      transform: translateY(-2px);
    }
    
    button:active:not(:disabled) {
      transform: translateY(0);
    }
    
    button:disabled {
      background: linear-gradient(135deg, #333 0%, #555 100%);
      border-color: #666;
      color: #888;
      cursor: not-allowed;
      box-shadow: none;
    }
    
    button.stop {
      background: linear-gradient(135deg, #ff00ff 0%, #ff0080 100%);
      border-color: #ff00ff;
      box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
    }
    
    button.stop:hover:not(:disabled) {
      box-shadow: 0 0 25px rgba(255, 0, 255, 0.8);
    }
    
    button.unstuck {
      background: linear-gradient(135deg, #ffff00 0%, #ffaa00 100%);
      border-color: #ffff00;
      box-shadow: 0 0 15px rgba(255, 255, 0, 0.5);
    }
    
    button.unstuck:hover:not(:disabled) {
      box-shadow: 0 0 25px rgba(255, 255, 0, 0.8);
    }
    
    button.reset {
      background: linear-gradient(135deg, #ff6600 0%, #ff3300 100%);
      border-color: #ff6600;
      box-shadow: 0 0 15px rgba(255, 102, 0, 0.5);
    }
    
    button.reset:hover:not(:disabled) {
      box-shadow: 0 0 25px rgba(255, 102, 0, 0.8);
    }
    
    .stats {
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #00ff00;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.3),
                  inset 0 0 20px rgba(0, 255, 0, 0.1);
    }
    
    .stats h2 {
      text-align: center;
      color: #00ff00;
      text-shadow: 0 0 15px #00ff00;
      margin-bottom: 15px;
      font-size: 1.5em;
      letter-spacing: 2px;
    }
    
    .stat-item {
      display: flex;
      justify-content: space-between;
      padding: 12px 15px;
      margin: 8px 0;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      border-left: 4px solid;
      font-size: 1.1em;
      transition: all 0.3s;
    }
    
    .stat-item:hover {
      background: rgba(255, 255, 255, 0.05);
      transform: translateX(5px);
    }
    
    .stat-item.red {
      border-left-color: #ff0000;
      color: #ff6666;
    }
    
    .stat-item.orange {
      border-left-color: #ff8800;
      color: #ffaa66;
    }
    
    .stat-item.green {
      border-left-color: #00ff00;
      color: #66ff66;
    }
    
    .stat-label {
      font-weight: bold;
      text-shadow: 0 0 10px currentColor;
    }
    
    .stat-value {
      font-weight: bold;
      font-size: 1.2em;
      text-shadow: 0 0 15px currentColor;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    .sorting-active {
      animation: pulse 2s infinite;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>TOMATO SORTER</h1>
    <div class="status" id="statusText"></div>
    
    <div class="buttons">
      <button id="mainBtn" onclick="toggleSorting()"></button>
      <button id="unstuckBtn" class="unstuck" onclick="unstuck()">Unstuck the sorter</button>
      <button id="resetBtn" class="reset" onclick="resetStats()">Reset Statistics</button>
    </div>
    
    <div class="stats">
      <h2>Tomato Count</h2>
      <div class="stat-item red">
        <span class="stat-label">Red Tomatoes:</span>
        <span class="stat-value" id="redCount">0</span>
      </div>
      <div class="stat-item orange">
        <span class="stat-label">Orange Tomatoes:</span>
        <span class="stat-value" id="orangeCount">0</span>
      </div>
      <div class="stat-item green">
        <span class="stat-label">Green Tomatoes:</span>
        <span class="stat-value" id="greenCount">0</span>
      </div>
    </div>
  </div>
  
  <script>
    let isSorting = false;
    
    function updateUI() {
      fetch('/status')
        .then(response => response.json())
        .then(data => {
          isSorting = data.isSorting;
          
          document.getElementById('redCount').textContent = data.countRed;
          document.getElementById('orangeCount').textContent = data.countOrange;
          document.getElementById('greenCount').textContent = data.countGreen;
          
          const mainBtn = document.getElementById('mainBtn');
          const unstuckBtn = document.getElementById('unstuckBtn');
          const resetBtn = document.getElementById('resetBtn');
          const statusText = document.getElementById('statusText');
          const container = document.querySelector('.container');
          
          if (isSorting) {
            mainBtn.textContent = 'Stop Sorting';
            mainBtn.className = 'stop';
            unstuckBtn.disabled = false;
            resetBtn.disabled = true;
            statusText.textContent = 'Sorting in progress....';
            statusText.className = 'status sorting-active';
          } else {
            mainBtn.textContent = 'Start Sorting';
            mainBtn.className = '';
            unstuckBtn.disabled = true;
            resetBtn.disabled = false;
            statusText.textContent = '';
            statusText.className = 'status';
          }
        })
        .catch(error => console.error('Error:', error));
    }
    
    function toggleSorting() {
      if (isSorting) {
        fetch('/stop')
          .then(() => updateUI())
          .catch(error => console.error('Error:', error));
      } else {
        fetch('/start')
          .then(() => updateUI())
          .catch(error => console.error('Error:', error));
      }
    }
    
    function unstuck() {
      if (isSorting) {
        fetch('/unstuck')
          .then(response => {
            if (response.ok) {
              alert('Unstuck command sent!');
            }
          })
          .catch(error => console.error('Error:', error));
      }
    }
    
    function resetStats() {
      if (!isSorting && confirm('Are you sure you want to reset all statistics?')) {
        fetch('/reset')
          .then(() => updateUI())
          .catch(error => console.error('Error:', error));
      }
    }
    
    // Update UI every 500ms
    setInterval(updateUI, 500);
    
    // Initial update
    updateUI();
  </script>
</body>
</html>
)rawliteral";
  
  return html;
}

// ==================== MAIN MENU ====================
void displayMainMenu() {
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_ncenB10_tr);
  u8g2.drawStr(5, 15, "Tomato Sorter");
  
  u8g2.setFont(u8g2_font_ncenB08_tr);
  
  // Start Sorting option
  if (menuIndex == 0) {
    u8g2.drawStr(5, 35, "> Start Sorting");
    u8g2.drawStr(5, 50, "  Statistics");
  } else {
    u8g2.drawStr(5, 35, "  Start Sorting");
    u8g2.drawStr(5, 50, "> Statistics");
  }
  
  u8g2.sendBuffer();
}

void handleMainMenu(unsigned long currentMillis) {
  if (checkButtonPress(BUTTON_UP, currentMillis)) {
    menuIndex = (menuIndex - 1 + 2) % 2;
    displayMainMenu();
  }
  
  if (checkButtonPress(BUTTON_DOWN, currentMillis)) {
    menuIndex = (menuIndex + 1) % 2;
    displayMainMenu();
  }
  
  if (checkButtonPress(BUTTON_SELECT, currentMillis)) {
    if (menuIndex == 0) {
      // Go to Sorting Screen
      isSorting = true;
      currentState = SORTING_SCREEN;
      displaySortingScreen();
    } else {
      // Go to Statistics Menu
      currentState = STATISTICS_MENU;
      menuIndex = 0;
      displayStatisticsMenu();
    }
  }
}

// ==================== STATISTICS MENU ====================
void displayStatisticsMenu() {
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_ncenB10_tr);
  u8g2.drawStr(5, 15, "Statistics");
  
  u8g2.setFont(u8g2_font_ncenB08_tr);
  
  // Display options with proper pointer
  if (menuIndex == 0) {
    u8g2.drawStr(5, 30, "> Check Statistics");
  } else {
    u8g2.drawStr(5, 30, "  Check Statistics");
  }
  
  if (menuIndex == 1) {
    u8g2.drawStr(5, 42, "> Reset");
  } else {
    u8g2.drawStr(5, 42, "  Reset");
  }
  
  if (menuIndex == 2) {
    u8g2.drawStr(5, 54, "> Back to Menu");
  } else {
    u8g2.drawStr(5, 54, "  Back to Menu");
  }
  
  u8g2.sendBuffer();
}

void handleStatisticsMenu(unsigned long currentMillis) {
  if (checkButtonPress(BUTTON_UP, currentMillis)) {
    menuIndex = (menuIndex - 1 + 3) % 3;
    displayStatisticsMenu();
  }
  
  if (checkButtonPress(BUTTON_DOWN, currentMillis)) {
    menuIndex = (menuIndex + 1) % 3;
    displayStatisticsMenu();
  }
  
  if (checkButtonPress(BUTTON_SELECT, currentMillis)) {
    if (menuIndex == 0) {
      // Check Statistics
      currentState = CHECK_STATISTICS;
      displayCheckStatistics();
    } else if (menuIndex == 1) {
      // Reset
      if (!isSorting) {
        countRed = 0;
        countOrange = 0;
        countGreen = 0;
        currentState = RESET_STATISTICS;
        displayResetMessage();
      }
    } else {
      // Back to Menu
      currentState = MAIN_MENU;
      menuIndex = 0;
      displayMainMenu();
    }
  }
}

// ==================== CHECK STATISTICS ====================
void displayCheckStatistics() {
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_ncenB08_tr);
  
  u8g2.drawStr(5, 12, ("Red: " + String(countRed)).c_str());
  u8g2.drawStr(5, 27, ("Orange: " + String(countOrange)).c_str());
  u8g2.drawStr(5, 42, ("Green: " + String(countGreen)).c_str());
  
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.drawStr(5, 58, "Press a button to return");
  
  u8g2.sendBuffer();
}

void handleCheckStatistics(unsigned long currentMillis) {
  if (checkButtonPress(BUTTON_UP, currentMillis) || 
      checkButtonPress(BUTTON_DOWN, currentMillis) || 
      checkButtonPress(BUTTON_SELECT, currentMillis)) {
    currentState = STATISTICS_MENU;
    menuIndex = 0;
    displayStatisticsMenu();
  }
}

// ==================== RESET STATISTICS ====================
void displayResetMessage() {
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_ncenB08_tr);
  
  u8g2.drawStr(10, 30, "Statistics has");
  u8g2.drawStr(10, 45, "been reset!");
  
  u8g2.sendBuffer();
  
  showingResetMessage = true;
  resetDisplayTime = millis();
}

// ==================== SORTING SCREEN ====================
void displaySortingScreen() {
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_ncenB08_tr);
  
  u8g2.drawStr(5, 15, "Sorting....");
  u8g2.drawStr(5, 30, "IP Address:");
  u8g2.drawStr(5, 45, ipAddress.c_str());
  
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.drawStr(5, 58, "Press a button to return");
  
  u8g2.sendBuffer();
}

void handleSortingScreen(unsigned long currentMillis) {
  if (checkButtonPress(BUTTON_UP, currentMillis) || 
      checkButtonPress(BUTTON_DOWN, currentMillis) || 
      checkButtonPress(BUTTON_SELECT, currentMillis)) {
    isSorting = false;
    currentState = MAIN_MENU;
    menuIndex = 0;
    displayMainMenu();
  }
}

// ==================== UTILITY FUNCTIONS ====================
bool checkButtonPress(int button, unsigned long currentMillis) {
  if (digitalRead(button) == LOW) {
    if (currentMillis - lastDebounceTime >= debounceInterval) {
      lastDebounceTime = currentMillis;
      Serial.print("Button pressed: ");
      Serial.println(button);
      return true;
    }
  }
  return false;
}
